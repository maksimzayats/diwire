from __future__ import annotations

import threading


from types import TracebackType
from typing import Any

from diwire.exceptions import (
    DIWireAsyncDependencyInSyncContextError,
    DIWireDependencyNotRegisteredError,
    DIWireScopeMismatchError,
)
from diwire.providers import ProvidersRegistrations
from diwire.resolvers.protocol import ResolverProtocol

_MISSING_RESOLVER: Any = object()
_MISSING_CACHE: Any = object()
_MISSING_PROVIDER: Any = object()

class RootResolver:
    def __init__(
        self,
        cleanup_enabled: bool = True,
    ) -> None:
        self._scope_level = 1
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = self
        self._app_resolver = self._root_resolver
        self._scope_resolver_2 = _SessionResolver(self._root_resolver, self._cleanup_enabled)
        self._scope_resolver_3 = _RequestResolver(self._root_resolver, self._cleanup_enabled)
        self._scope_resolver_4 = _ActionResolver(self._root_resolver, self._cleanup_enabled)
        self._scope_resolver_5 = _StepResolver(self._root_resolver, self._cleanup_enabled)

    def enter_scope(self, scope: Any | None = None) -> ResolverProtocol:
        if scope is None:
            return self._root_resolver._scope_resolver_3
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 2:
            return self._root_resolver._scope_resolver_2
        if target_scope_level == 3:
            return self._root_resolver._scope_resolver_3
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> ResolverProtocol:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> ResolverProtocol:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


class _SessionResolver:
    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
    ) -> None:
        self._scope_level = 2
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._app_resolver = self._root_resolver

    def enter_scope(self, scope: Any | None = None) -> ResolverProtocol:
        if scope is None:
            return self._root_resolver._scope_resolver_3
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 3:
            return self._root_resolver._scope_resolver_3
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> ResolverProtocol:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> ResolverProtocol:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


class _RequestResolver:
    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
    ) -> None:
        self._scope_level = 3
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._app_resolver = self._root_resolver

    def enter_scope(self, scope: Any | None = None) -> ResolverProtocol:
        if scope is None:
            return self._root_resolver._scope_resolver_4
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 4:
            return self._root_resolver._scope_resolver_4
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> ResolverProtocol:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> ResolverProtocol:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


class _ActionResolver:
    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
    ) -> None:
        self._scope_level = 4
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._app_resolver = self._root_resolver

    def enter_scope(self, scope: Any | None = None) -> ResolverProtocol:
        if scope is None:
            return self._root_resolver._scope_resolver_5
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 5:
            return self._root_resolver._scope_resolver_5
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> ResolverProtocol:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> ResolverProtocol:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


class _StepResolver:
    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
    ) -> None:
        self._scope_level = 5
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._app_resolver = self._root_resolver

    def enter_scope(self, scope: Any | None = None) -> ResolverProtocol:
        msg = f"Cannot enter deeper scope from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> ResolverProtocol:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> ResolverProtocol:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

def build_root_resolver(
    registrations: ProvidersRegistrations,
    *,
    cleanup_enabled: bool = True,
) -> ResolverProtocol:
    return RootResolver(cleanup_enabled)