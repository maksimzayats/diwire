"""
Generated DI resolver module.

Generated by: diwire.resolvers.templates.renderer.ResolversTemplateRenderer.get_providers_code
diwire version used for generation: 0.1.0.post43.dev0+b683984

Generation configuration:
- root scope level: 1
- managed scopes: app:1, session:2, request:3, action:4, step:5
- lock mode: thread
- cleanup support enabled in graph: False
- provider count: 0
- provider slots: none

Examples:
>>> root = build_root_resolver(registrations)
>>> service = root.resolve(SomeService)
>>> async_service = await root.aresolve(SomeAsyncService)
>>> request_scope = root.enter_scope()
>>> scoped_service = request_scope.resolve(RequestScopedService)
"""

from __future__ import annotations

import threading


from types import TracebackType
from typing import Any, NoReturn

from diwire.exceptions import (
    DIWireAsyncDependencyInSyncContextError,
    DIWireDependencyNotRegisteredError,
    DIWireScopeMismatchError,
)
from diwire.providers import ProvidersRegistrations

_MISSING_RESOLVER: Any = object()
_MISSING_CACHE: Any = object()
_MISSING_PROVIDER: Any = object()

class RootResolver:

    """
    Generated resolver for scope 'app' (level 1).

    This class is generated and optimized for direct slot-based dependency resolution.
    All visible provider slots: none.
    Providers declared in this exact scope: none.
    """



    __slots__ = (
        "_root_resolver",
        "__dict__",
        "_scope_resolver_2",
        "_scope_resolver_3",
        "_scope_resolver_4",
        "_scope_resolver_5",
    )


    def __init__(
        self,

    ) -> None:

        """
        Initialize resolver state for the current scope.

        The constructor wires scope ancestry references, cache slots, and optional cleanup state.
        Root scope class: RootResolver.
        Stateless scope reuse enabled: True.
        """

        self._root_resolver = self
        self._scope_resolver_2 = _SessionResolver(self._root_resolver)
        self._scope_resolver_3 = _RequestResolver(self._root_resolver)
        self._scope_resolver_4 = _ActionResolver(self._root_resolver)
        self._scope_resolver_5 = _StepResolver(self._root_resolver)

    def enter_scope(self, scope: Any | None = None) -> RootResolver | _SessionResolver | _RequestResolver:

        """
        Open a deeper scope resolver from this resolver.

        Current scope: app:1.
        Allowed explicit transitions: session:2, request:3.
        Passing None follows the default transition for the scope graph.
        """

        if scope == 3:
            return self._root_resolver._scope_resolver_3
        if scope is None:
            return self._root_resolver._scope_resolver_3
        target_scope_level = scope
        if target_scope_level == 1:
            return self
        if target_scope_level <= 1:
            msg = f"Cannot enter scope level {target_scope_level} from level 1."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 2:
            return self._root_resolver._scope_resolver_2
        msg = f"Scope level {target_scope_level} is not a valid next transition from level 1."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated synchronous provider resolver method.

        Known provider slots: none.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks to avoid reflective dispatch.
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated asynchronous provider resolver method.

        Known provider slots: none.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks for asynchronous resolution.
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> RootResolver:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> RootResolver:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


class _SessionResolver:

    """
    Generated resolver for scope 'session' (level 2).

    This class is generated and optimized for direct slot-based dependency resolution.
    All visible provider slots: none.
    Providers declared in this exact scope: none.
    """



    __slots__ = (
        "_root_resolver",
    )


    def __init__(
        self,
        root_resolver: RootResolver,
    ) -> None:

        """
        Initialize resolver state for the current scope.

        The constructor wires scope ancestry references, cache slots, and optional cleanup state.
        Root scope class: RootResolver.
        Stateless scope reuse enabled: True.
        """

        self._root_resolver = root_resolver

    def enter_scope(self, scope: Any | None = None) -> _SessionResolver | _RequestResolver:

        """
        Open a deeper scope resolver from this resolver.

        Current scope: session:2.
        Allowed explicit transitions: request:3.
        Passing None follows the default transition for the scope graph.
        """

        if scope == 3:
            return self._root_resolver._scope_resolver_3
        if scope is None:
            return self._root_resolver._scope_resolver_3
        target_scope_level = scope
        if target_scope_level == 2:
            return self
        if target_scope_level <= 2:
            msg = f"Cannot enter scope level {target_scope_level} from level 2."
            raise DIWireScopeMismatchError(msg)
        msg = f"Scope level {target_scope_level} is not a valid next transition from level 2."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated synchronous provider resolver method.

        Known provider slots: none.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks to avoid reflective dispatch.
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated asynchronous provider resolver method.

        Known provider slots: none.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks for asynchronous resolution.
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> _SessionResolver:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> _SessionResolver:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


class _RequestResolver:

    """
    Generated resolver for scope 'request' (level 3).

    This class is generated and optimized for direct slot-based dependency resolution.
    All visible provider slots: none.
    Providers declared in this exact scope: none.
    """



    __slots__ = (
        "_root_resolver",
    )


    def __init__(
        self,
        root_resolver: RootResolver,
    ) -> None:

        """
        Initialize resolver state for the current scope.

        The constructor wires scope ancestry references, cache slots, and optional cleanup state.
        Root scope class: RootResolver.
        Stateless scope reuse enabled: True.
        """

        self._root_resolver = root_resolver

    def enter_scope(self, scope: Any | None = None) -> _RequestResolver | _ActionResolver:

        """
        Open a deeper scope resolver from this resolver.

        Current scope: request:3.
        Allowed explicit transitions: action:4.
        Passing None follows the default transition for the scope graph.
        """

        if scope == 4:
            return self._root_resolver._scope_resolver_4
        if scope is None:
            return self._root_resolver._scope_resolver_4
        target_scope_level = scope
        if target_scope_level == 3:
            return self
        if target_scope_level <= 3:
            msg = f"Cannot enter scope level {target_scope_level} from level 3."
            raise DIWireScopeMismatchError(msg)
        msg = f"Scope level {target_scope_level} is not a valid next transition from level 3."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated synchronous provider resolver method.

        Known provider slots: none.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks to avoid reflective dispatch.
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated asynchronous provider resolver method.

        Known provider slots: none.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks for asynchronous resolution.
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> _RequestResolver:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> _RequestResolver:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


class _ActionResolver:

    """
    Generated resolver for scope 'action' (level 4).

    This class is generated and optimized for direct slot-based dependency resolution.
    All visible provider slots: none.
    Providers declared in this exact scope: none.
    """



    __slots__ = (
        "_root_resolver",
    )


    def __init__(
        self,
        root_resolver: RootResolver,
    ) -> None:

        """
        Initialize resolver state for the current scope.

        The constructor wires scope ancestry references, cache slots, and optional cleanup state.
        Root scope class: RootResolver.
        Stateless scope reuse enabled: True.
        """

        self._root_resolver = root_resolver

    def enter_scope(self, scope: Any | None = None) -> _ActionResolver | _StepResolver:

        """
        Open a deeper scope resolver from this resolver.

        Current scope: action:4.
        Allowed explicit transitions: step:5.
        Passing None follows the default transition for the scope graph.
        """

        if scope == 5:
            return self._root_resolver._scope_resolver_5
        if scope is None:
            return self._root_resolver._scope_resolver_5
        target_scope_level = scope
        if target_scope_level == 4:
            return self
        if target_scope_level <= 4:
            msg = f"Cannot enter scope level {target_scope_level} from level 4."
            raise DIWireScopeMismatchError(msg)
        msg = f"Scope level {target_scope_level} is not a valid next transition from level 4."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated synchronous provider resolver method.

        Known provider slots: none.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks to avoid reflective dispatch.
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated asynchronous provider resolver method.

        Known provider slots: none.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks for asynchronous resolution.
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> _ActionResolver:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> _ActionResolver:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


class _StepResolver:

    """
    Generated resolver for scope 'step' (level 5).

    This class is generated and optimized for direct slot-based dependency resolution.
    All visible provider slots: none.
    Providers declared in this exact scope: none.
    """



    __slots__ = (
        "_root_resolver",
    )


    def __init__(
        self,
        root_resolver: RootResolver,
    ) -> None:

        """
        Initialize resolver state for the current scope.

        The constructor wires scope ancestry references, cache slots, and optional cleanup state.
        Root scope class: RootResolver.
        Stateless scope reuse enabled: True.
        """

        self._root_resolver = root_resolver

    def enter_scope(self, scope: Any | None = None) -> NoReturn:

        """
        Open a deeper scope resolver from this resolver.

        Current scope: step:5.
        Allowed explicit transitions: none.
        Passing None follows the default transition for the scope graph.
        """

        msg = "Cannot enter deeper scope from level 5."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated synchronous provider resolver method.

        Known provider slots: none.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks to avoid reflective dispatch.
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated asynchronous provider resolver method.

        Known provider slots: none.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks for asynchronous resolution.
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> _StepResolver:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> _StepResolver:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

def build_root_resolver(
    registrations: ProvidersRegistrations,
    *,
    cleanup_enabled: bool = True,
) -> RootResolver:

    """
    Build and return the generated root resolver instance.

    This function rebinds module-level provider globals for the supplied registrations.
    Global rebinding makes `resolve_<slot>` methods run without registration lookups.
    Provider slots configured during bootstrap: none.
    Root resolver class: RootResolver.

    Examples:
    >>> root = build_root_resolver(registrations)
    >>> root.resolve(SomeService)
    >>> await root.aresolve(SomeAsyncService)
    >>> scoped = root.enter_scope()
    """

    # Bind module-level globals to this container registration snapshot.
    # This keeps hot paths in resolver methods free from dictionary lookups.
    # No provider registrations are active for the selected root scope.

    # Construct a fresh root resolver configured with optional cleanup callbacks.
    return RootResolver()