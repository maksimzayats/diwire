"""
Generated DI resolver module.

Generated by: diwire.resolvers.templates.renderer.ResolversTemplateRenderer.get_providers_code
diwire version used for generation: 0.1.0.post39.dev0+4dc6588

Generation configuration:
- root scope level: 1
- managed scopes: app:1, session:2, request:3, action:4, step:5
- lock mode: async
- cleanup support enabled in graph: True
- provider count: 4
- provider slots: 1, 2, 3, 4

Examples:
>>> root = build_root_resolver(registrations)
>>> service = root.resolve(SomeService)
>>> async_service = await root.aresolve(SomeAsyncService)
>>> request_scope = root.enter_scope()
>>> scoped_service = request_scope.resolve(RequestScopedService)
"""

from __future__ import annotations

import asyncio


from types import TracebackType
from typing import Any, NoReturn

from diwire.exceptions import (
    DIWireAsyncDependencyInSyncContextError,
    DIWireDependencyNotRegisteredError,
    DIWireScopeMismatchError,
)
from diwire.providers import ProvidersRegistrations

_MISSING_RESOLVER: Any = object()
_MISSING_CACHE: Any = object()
_MISSING_PROVIDER: Any = object()

_dep_1_type: Any = _MISSING_PROVIDER
_provider_1: Any = _MISSING_PROVIDER
_dep_2_type: Any = _MISSING_PROVIDER
_provider_2: Any = _MISSING_PROVIDER
_dep_3_type: Any = _MISSING_PROVIDER
_provider_3: Any = _MISSING_PROVIDER
_dep_4_type: Any = _MISSING_PROVIDER
_provider_4: Any = _MISSING_PROVIDER


_dep_1_async_lock = asyncio.Lock()
_dep_4_async_lock = asyncio.Lock()

class RootResolver:

    """
    Generated resolver for scope 'app' (level 1).

    This class is generated and optimized for direct slot-based dependency resolution.
    All visible provider slots: 1, 2, 3, 4.
    Providers declared in this exact scope: 2, 3.
    """



    __slots__ = (
        "_scope_level",
        "_root_resolver",
        "_cleanup_enabled",
        "__dict__",
        "_cleanup_callbacks",
        "_cache_2",
        "_cache_3",
    )


    def __init__(
        self,
        cleanup_enabled: bool = True,
    ) -> None:

        """
        Initialize resolver state for the current scope.

        The constructor wires scope ancestry references, cache slots, and optional cleanup state.
        Root scope class: RootResolver.
        Stateless scope reuse enabled: False.
        """

        self._scope_level = 1
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = self
        self._cleanup_callbacks: list[tuple[int, Any]] = []
        self._cache_2 = _MISSING_CACHE
        self._cache_3 = _MISSING_CACHE

    def enter_scope(self, scope: Any | None = None) -> RootResolver | _SessionResolver | _RequestResolver:

        """
        Open a deeper scope resolver from this resolver.

        Current scope: app:1.
        Allowed explicit transitions: session:2, request:3.
        Passing None follows the default transition for the scope graph.
        """

        if scope is None:
            return _RequestResolver(
                self._root_resolver,
                self._cleanup_enabled,
            )
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 2:
            return _SessionResolver(
                self._root_resolver,
                self._cleanup_enabled,
            )
        if target_scope_level == 3:
            return _RequestResolver(
                self._root_resolver,
                self._cleanup_enabled,
            )
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated synchronous provider resolver method.

        Known provider slots: 1, 2, 3, 4.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks to avoid reflective dispatch.
        if dependency is _dep_2_type:
            return self.resolve_2()
        if dependency is _dep_3_type:
            return self.resolve_3()
        if dependency is _dep_1_type:
            return self.resolve_1()
        if dependency is _dep_4_type:
            return self.resolve_4()
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated asynchronous provider resolver method.

        Known provider slots: 1, 2, 3, 4.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks for asynchronous resolution.
        if dependency is _dep_2_type:
            return await self.aresolve_2()
        if dependency is _dep_3_type:
            return await self.aresolve_3()
        if dependency is _dep_1_type:
            return await self.aresolve_1()
        if dependency is _dep_4_type:
            return await self.aresolve_4()
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> RootResolver:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        cleanup_error: BaseException | None = None
        while self._cleanup_callbacks:
            cleanup_kind, cleanup = self._cleanup_callbacks.pop()
            try:
                if cleanup_kind == 0:
                    cleanup(exc_type, exc_value, traceback)
                else:
                    msg = "Cannot execute async cleanup in sync context. Use 'async with'."
                    raise DIWireAsyncDependencyInSyncContextError(msg)
            except BaseException as error:
                if exc_type is None and cleanup_error is None:
                    cleanup_error = error
        if exc_type is None and cleanup_error is not None:
            raise cleanup_error
        return None

    async def __aenter__(self) -> RootResolver:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        cleanup_error: BaseException | None = None
        while self._cleanup_callbacks:
            cleanup_kind, cleanup = self._cleanup_callbacks.pop()
            try:
                if cleanup_kind == 0:
                    cleanup(exc_type, exc_value, traceback)
                else:
                    await cleanup(exc_type, exc_value, traceback)
            except BaseException as error:
                if exc_type is None and cleanup_error is None:
                    cleanup_error = error
        if exc_type is None and cleanup_error is not None:
            raise cleanup_error
        return None


    def resolve_1(self) -> Any:

        """
        Provider slot 1 resolver (sync method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource
        Provider spec kind: context_manager
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._provide_async_context_resource
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: True
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: RootResolver
        Dependency wiring: none
        Behavior: This resolver cannot access the provider yet because the required scope is deeper than the current resolver scope.
        """

        msg = "Provider slot 1 requires opened scope level 3."
        raise DIWireScopeMismatchError(msg)

    async def aresolve_1(self) -> Any:

        """
        Provider slot 1 resolver (async method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource
        Provider spec kind: context_manager
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._provide_async_context_resource
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: True
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: RootResolver
        Dependency wiring: none
        Behavior: This resolver cannot access the provider yet because the required scope is deeper than the current resolver scope.
        """

        msg = "Provider slot 1 requires opened scope level 3."
        raise DIWireScopeMismatchError(msg)

    def resolve_2(self) -> Any:

        """
        Provider slot 2 resolver (sync method).

        Returns: tuple
        Provider spec kind: instance
        Provider target: instance of tuple
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: RootResolver
        Dependency wiring: none
        Behavior: Builds the provider value in this resolver, enforcing scope guards and cache policy.
        """

        cached_value = self._cache_2
        if cached_value is not _MISSING_CACHE:
            return cached_value
        value = _provider_2
        self._cache_2 = value
        self.resolve_2 = lambda: value  # type: ignore[method-assign]

        async def _cached() -> Any:
            return value

        self.aresolve_2 = _cached  # type: ignore[method-assign]
        return value

    async def aresolve_2(self) -> Any:

        """
        Provider slot 2 resolver (async method).

        Returns: tuple
        Provider spec kind: instance
        Provider target: instance of tuple
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: RootResolver
        Dependency wiring: none
        Behavior: Async variant delegates to sync resolution because this provider graph does not require awaitable operations.
        """

        return self.resolve_2()

    def resolve_3(self) -> Any:

        """
        Provider slot 3 resolver (sync method).

        Returns: dict
        Provider spec kind: instance
        Provider target: instance of dict
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: RootResolver
        Dependency wiring: none
        Behavior: Builds the provider value in this resolver, enforcing scope guards and cache policy.
        """

        cached_value = self._cache_3
        if cached_value is not _MISSING_CACHE:
            return cached_value
        value = _provider_3
        self._cache_3 = value
        self.resolve_3 = lambda: value  # type: ignore[method-assign]

        async def _cached() -> Any:
            return value

        self.aresolve_3 = _cached  # type: ignore[method-assign]
        return value

    async def aresolve_3(self) -> Any:

        """
        Provider slot 3 resolver (async method).

        Returns: dict
        Provider spec kind: instance
        Provider target: instance of dict
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: RootResolver
        Dependency wiring: none
        Behavior: Async variant delegates to sync resolution because this provider graph does not require awaitable operations.
        """

        return self.resolve_3()

    def resolve_4(self) -> Any:

        """
        Provider slot 4 resolver (sync method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncCleanupSignatureService
        Provider spec kind: factory
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._build_snapshot_async_cleanup_signature_service
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: RootResolver
        Dependency wiring: dependency (positional_only) -> slot 1 [tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource]; values (var_positional) -> slot 2 [tuple]; options (var_keyword) -> slot 3 [dict]
        Behavior: This resolver cannot access the provider yet because the required scope is deeper than the current resolver scope.
        """

        msg = "Provider slot 4 requires opened scope level 3."
        raise DIWireScopeMismatchError(msg)

    async def aresolve_4(self) -> Any:

        """
        Provider slot 4 resolver (async method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncCleanupSignatureService
        Provider spec kind: factory
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._build_snapshot_async_cleanup_signature_service
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: RootResolver
        Dependency wiring: dependency (positional_only) -> slot 1 [tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource]; values (var_positional) -> slot 2 [tuple]; options (var_keyword) -> slot 3 [dict]
        Behavior: This resolver cannot access the provider yet because the required scope is deeper than the current resolver scope.
        """

        msg = "Provider slot 4 requires opened scope level 3."
        raise DIWireScopeMismatchError(msg)


class _SessionResolver:

    """
    Generated resolver for scope 'session' (level 2).

    This class is generated and optimized for direct slot-based dependency resolution.
    All visible provider slots: 1, 2, 3, 4.
    Providers declared in this exact scope: none.
    """



    __slots__ = (
        "_scope_level",
        "_root_resolver",
        "_cleanup_enabled",
        "_cleanup_callbacks",
        "_session_resolver",
    )


    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
    ) -> None:

        """
        Initialize resolver state for the current scope.

        The constructor wires scope ancestry references, cache slots, and optional cleanup state.
        Root scope class: RootResolver.
        Stateless scope reuse enabled: False.
        """

        self._scope_level = 2
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._cleanup_callbacks: list[tuple[int, Any]] = []
        self._session_resolver = self

    def enter_scope(self, scope: Any | None = None) -> _SessionResolver | _RequestResolver:

        """
        Open a deeper scope resolver from this resolver.

        Current scope: session:2.
        Allowed explicit transitions: request:3.
        Passing None follows the default transition for the scope graph.
        """

        if scope is None:
            return _RequestResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self,
            )
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 3:
            return _RequestResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self,
            )
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated synchronous provider resolver method.

        Known provider slots: 1, 2, 3, 4.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks to avoid reflective dispatch.
        if dependency is _dep_1_type:
            return self.resolve_1()
        if dependency is _dep_2_type:
            return self.resolve_2()
        if dependency is _dep_3_type:
            return self.resolve_3()
        if dependency is _dep_4_type:
            return self.resolve_4()
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated asynchronous provider resolver method.

        Known provider slots: 1, 2, 3, 4.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks for asynchronous resolution.
        if dependency is _dep_1_type:
            return await self.aresolve_1()
        if dependency is _dep_2_type:
            return await self.aresolve_2()
        if dependency is _dep_3_type:
            return await self.aresolve_3()
        if dependency is _dep_4_type:
            return await self.aresolve_4()
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> _SessionResolver:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        cleanup_error: BaseException | None = None
        while self._cleanup_callbacks:
            cleanup_kind, cleanup = self._cleanup_callbacks.pop()
            try:
                if cleanup_kind == 0:
                    cleanup(exc_type, exc_value, traceback)
                else:
                    msg = "Cannot execute async cleanup in sync context. Use 'async with'."
                    raise DIWireAsyncDependencyInSyncContextError(msg)
            except BaseException as error:
                if exc_type is None and cleanup_error is None:
                    cleanup_error = error
        if exc_type is None and cleanup_error is not None:
            raise cleanup_error
        return None

    async def __aenter__(self) -> _SessionResolver:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        cleanup_error: BaseException | None = None
        while self._cleanup_callbacks:
            cleanup_kind, cleanup = self._cleanup_callbacks.pop()
            try:
                if cleanup_kind == 0:
                    cleanup(exc_type, exc_value, traceback)
                else:
                    await cleanup(exc_type, exc_value, traceback)
            except BaseException as error:
                if exc_type is None and cleanup_error is None:
                    cleanup_error = error
        if exc_type is None and cleanup_error is not None:
            raise cleanup_error
        return None


    def resolve_1(self) -> Any:

        """
        Provider slot 1 resolver (sync method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource
        Provider spec kind: context_manager
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._provide_async_context_resource
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: True
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _SessionResolver
        Dependency wiring: none
        Behavior: This resolver cannot access the provider yet because the required scope is deeper than the current resolver scope.
        """

        msg = "Provider slot 1 requires opened scope level 3."
        raise DIWireScopeMismatchError(msg)

    async def aresolve_1(self) -> Any:

        """
        Provider slot 1 resolver (async method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource
        Provider spec kind: context_manager
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._provide_async_context_resource
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: True
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _SessionResolver
        Dependency wiring: none
        Behavior: This resolver cannot access the provider yet because the required scope is deeper than the current resolver scope.
        """

        msg = "Provider slot 1 requires opened scope level 3."
        raise DIWireScopeMismatchError(msg)

    def resolve_2(self) -> Any:

        """
        Provider slot 2 resolver (sync method).

        Returns: tuple
        Provider spec kind: instance
        Provider target: instance of tuple
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _SessionResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        return self._root_resolver.resolve_2()

    async def aresolve_2(self) -> Any:

        """
        Provider slot 2 resolver (async method).

        Returns: tuple
        Provider spec kind: instance
        Provider target: instance of tuple
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _SessionResolver
        Dependency wiring: none
        Behavior: Async variant delegates to sync resolution because this provider graph does not require awaitable operations.
        """

        return self.resolve_2()

    def resolve_3(self) -> Any:

        """
        Provider slot 3 resolver (sync method).

        Returns: dict
        Provider spec kind: instance
        Provider target: instance of dict
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _SessionResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        return self._root_resolver.resolve_3()

    async def aresolve_3(self) -> Any:

        """
        Provider slot 3 resolver (async method).

        Returns: dict
        Provider spec kind: instance
        Provider target: instance of dict
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _SessionResolver
        Dependency wiring: none
        Behavior: Async variant delegates to sync resolution because this provider graph does not require awaitable operations.
        """

        return self.resolve_3()

    def resolve_4(self) -> Any:

        """
        Provider slot 4 resolver (sync method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncCleanupSignatureService
        Provider spec kind: factory
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._build_snapshot_async_cleanup_signature_service
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _SessionResolver
        Dependency wiring: dependency (positional_only) -> slot 1 [tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource]; values (var_positional) -> slot 2 [tuple]; options (var_keyword) -> slot 3 [dict]
        Behavior: This resolver cannot access the provider yet because the required scope is deeper than the current resolver scope.
        """

        msg = "Provider slot 4 requires opened scope level 3."
        raise DIWireScopeMismatchError(msg)

    async def aresolve_4(self) -> Any:

        """
        Provider slot 4 resolver (async method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncCleanupSignatureService
        Provider spec kind: factory
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._build_snapshot_async_cleanup_signature_service
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _SessionResolver
        Dependency wiring: dependency (positional_only) -> slot 1 [tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource]; values (var_positional) -> slot 2 [tuple]; options (var_keyword) -> slot 3 [dict]
        Behavior: This resolver cannot access the provider yet because the required scope is deeper than the current resolver scope.
        """

        msg = "Provider slot 4 requires opened scope level 3."
        raise DIWireScopeMismatchError(msg)


class _RequestResolver:

    """
    Generated resolver for scope 'request' (level 3).

    This class is generated and optimized for direct slot-based dependency resolution.
    All visible provider slots: 1, 2, 3, 4.
    Providers declared in this exact scope: 1, 4.
    """



    __slots__ = (
        "_scope_level",
        "_root_resolver",
        "_cleanup_enabled",
        "_cleanup_callbacks",
        "_session_resolver",
        "_request_resolver",
        "_cache_1",
        "_cache_4",
    )


    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
        session_resolver: Any = _MISSING_RESOLVER,
    ) -> None:

        """
        Initialize resolver state for the current scope.

        The constructor wires scope ancestry references, cache slots, and optional cleanup state.
        Root scope class: RootResolver.
        Stateless scope reuse enabled: False.
        """

        self._scope_level = 3
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._cleanup_callbacks: list[tuple[int, Any]] = []
        self._session_resolver = session_resolver
        self._request_resolver = self
        self._cache_1 = _MISSING_CACHE
        self._cache_4 = _MISSING_CACHE

    def enter_scope(self, scope: Any | None = None) -> _RequestResolver | _ActionResolver:

        """
        Open a deeper scope resolver from this resolver.

        Current scope: request:3.
        Allowed explicit transitions: action:4.
        Passing None follows the default transition for the scope graph.
        """

        if scope is None:
            return _ActionResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self._session_resolver,
                self,
            )
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 4:
            return _ActionResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self._session_resolver,
                self,
            )
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated synchronous provider resolver method.

        Known provider slots: 1, 2, 3, 4.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks to avoid reflective dispatch.
        if dependency is _dep_1_type:
            return self.resolve_1()
        if dependency is _dep_4_type:
            return self.resolve_4()
        if dependency is _dep_2_type:
            return self.resolve_2()
        if dependency is _dep_3_type:
            return self.resolve_3()
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated asynchronous provider resolver method.

        Known provider slots: 1, 2, 3, 4.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks for asynchronous resolution.
        if dependency is _dep_1_type:
            return await self.aresolve_1()
        if dependency is _dep_4_type:
            return await self.aresolve_4()
        if dependency is _dep_2_type:
            return await self.aresolve_2()
        if dependency is _dep_3_type:
            return await self.aresolve_3()
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> _RequestResolver:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        cleanup_error: BaseException | None = None
        while self._cleanup_callbacks:
            cleanup_kind, cleanup = self._cleanup_callbacks.pop()
            try:
                if cleanup_kind == 0:
                    cleanup(exc_type, exc_value, traceback)
                else:
                    msg = "Cannot execute async cleanup in sync context. Use 'async with'."
                    raise DIWireAsyncDependencyInSyncContextError(msg)
            except BaseException as error:
                if exc_type is None and cleanup_error is None:
                    cleanup_error = error
        if exc_type is None and cleanup_error is not None:
            raise cleanup_error
        return None

    async def __aenter__(self) -> _RequestResolver:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        cleanup_error: BaseException | None = None
        while self._cleanup_callbacks:
            cleanup_kind, cleanup = self._cleanup_callbacks.pop()
            try:
                if cleanup_kind == 0:
                    cleanup(exc_type, exc_value, traceback)
                else:
                    await cleanup(exc_type, exc_value, traceback)
            except BaseException as error:
                if exc_type is None and cleanup_error is None:
                    cleanup_error = error
        if exc_type is None and cleanup_error is not None:
            raise cleanup_error
        return None


    def resolve_1(self) -> Any:

        """
        Provider slot 1 resolver (sync method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource
        Provider spec kind: context_manager
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._provide_async_context_resource
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: True
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _RequestResolver
        Dependency wiring: none
        Behavior: Synchronous access is blocked because the provider graph requires async resolution.
        """

        provider_scope_resolver = self
        msg = "Provider slot 1 requires asynchronous resolution."
        raise DIWireAsyncDependencyInSyncContextError(msg)

    async def aresolve_1(self) -> Any:

        """
        Provider slot 1 resolver (async method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource
        Provider spec kind: context_manager
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._provide_async_context_resource
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: True
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _RequestResolver
        Dependency wiring: none
        Behavior: Builds the provider value in this resolver, enforcing scope guards and cache policy.
        """

        provider_scope_resolver = self
        cached_value = self._cache_1
        if cached_value is not _MISSING_CACHE:
            return cached_value
        async with _dep_1_async_lock:
            cached_value = self._cache_1
            if cached_value is not _MISSING_CACHE:
                return cached_value
            _provider_cm = _provider_1()
            value = await _provider_cm.__aenter__()
            if self._cleanup_enabled:
                provider_scope_resolver._cleanup_callbacks.append((1, _provider_cm.__aexit__))
            self._cache_1 = value
            return value

    def resolve_2(self) -> Any:

        """
        Provider slot 2 resolver (sync method).

        Returns: tuple
        Provider spec kind: instance
        Provider target: instance of tuple
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _RequestResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        return self._root_resolver.resolve_2()

    async def aresolve_2(self) -> Any:

        """
        Provider slot 2 resolver (async method).

        Returns: tuple
        Provider spec kind: instance
        Provider target: instance of tuple
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _RequestResolver
        Dependency wiring: none
        Behavior: Async variant delegates to sync resolution because this provider graph does not require awaitable operations.
        """

        return self.resolve_2()

    def resolve_3(self) -> Any:

        """
        Provider slot 3 resolver (sync method).

        Returns: dict
        Provider spec kind: instance
        Provider target: instance of dict
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _RequestResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        return self._root_resolver.resolve_3()

    async def aresolve_3(self) -> Any:

        """
        Provider slot 3 resolver (async method).

        Returns: dict
        Provider spec kind: instance
        Provider target: instance of dict
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _RequestResolver
        Dependency wiring: none
        Behavior: Async variant delegates to sync resolution because this provider graph does not require awaitable operations.
        """

        return self.resolve_3()

    def resolve_4(self) -> Any:

        """
        Provider slot 4 resolver (sync method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncCleanupSignatureService
        Provider spec kind: factory
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._build_snapshot_async_cleanup_signature_service
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _RequestResolver
        Dependency wiring: dependency (positional_only) -> slot 1 [tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource]; values (var_positional) -> slot 2 [tuple]; options (var_keyword) -> slot 3 [dict]
        Behavior: Synchronous access is blocked because the provider graph requires async resolution.
        """

        msg = "Provider slot 4 requires asynchronous resolution."
        raise DIWireAsyncDependencyInSyncContextError(msg)

    async def aresolve_4(self) -> Any:

        """
        Provider slot 4 resolver (async method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncCleanupSignatureService
        Provider spec kind: factory
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._build_snapshot_async_cleanup_signature_service
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _RequestResolver
        Dependency wiring: dependency (positional_only) -> slot 1 [tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource]; values (var_positional) -> slot 2 [tuple]; options (var_keyword) -> slot 3 [dict]
        Behavior: Builds the provider value in this resolver, enforcing scope guards and cache policy.
        """

        cached_value = self._cache_4
        if cached_value is not _MISSING_CACHE:
            return cached_value
        async with _dep_4_async_lock:
            cached_value = self._cache_4
            if cached_value is not _MISSING_CACHE:
                return cached_value
            value = _provider_4(
                await self.aresolve_1(),
                *self._root_resolver._cache_2 if self._root_resolver._cache_2 is not _MISSING_CACHE else self._root_resolver.resolve_2(),
                **self._root_resolver._cache_3 if self._root_resolver._cache_3 is not _MISSING_CACHE else self._root_resolver.resolve_3(),
            )
            self._cache_4 = value
            return value


class _ActionResolver:

    """
    Generated resolver for scope 'action' (level 4).

    This class is generated and optimized for direct slot-based dependency resolution.
    All visible provider slots: 1, 2, 3, 4.
    Providers declared in this exact scope: none.
    """



    __slots__ = (
        "_scope_level",
        "_root_resolver",
        "_cleanup_enabled",
        "_cleanup_callbacks",
        "_session_resolver",
        "_request_resolver",
        "_action_resolver",
    )


    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
        session_resolver: Any = _MISSING_RESOLVER,
        request_resolver: Any = _MISSING_RESOLVER,
    ) -> None:

        """
        Initialize resolver state for the current scope.

        The constructor wires scope ancestry references, cache slots, and optional cleanup state.
        Root scope class: RootResolver.
        Stateless scope reuse enabled: False.
        """

        self._scope_level = 4
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._cleanup_callbacks: list[tuple[int, Any]] = []
        self._session_resolver = session_resolver
        self._request_resolver = request_resolver
        self._action_resolver = self

    def enter_scope(self, scope: Any | None = None) -> _ActionResolver | _StepResolver:

        """
        Open a deeper scope resolver from this resolver.

        Current scope: action:4.
        Allowed explicit transitions: step:5.
        Passing None follows the default transition for the scope graph.
        """

        if scope is None:
            return _StepResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self._session_resolver,
                self._request_resolver,
                self,
            )
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 5:
            return _StepResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self._session_resolver,
                self._request_resolver,
                self,
            )
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated synchronous provider resolver method.

        Known provider slots: 1, 2, 3, 4.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks to avoid reflective dispatch.
        if dependency is _dep_1_type:
            return self.resolve_1()
        if dependency is _dep_4_type:
            return self.resolve_4()
        if dependency is _dep_2_type:
            return self.resolve_2()
        if dependency is _dep_3_type:
            return self.resolve_3()
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated asynchronous provider resolver method.

        Known provider slots: 1, 2, 3, 4.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks for asynchronous resolution.
        if dependency is _dep_1_type:
            return await self.aresolve_1()
        if dependency is _dep_4_type:
            return await self.aresolve_4()
        if dependency is _dep_2_type:
            return await self.aresolve_2()
        if dependency is _dep_3_type:
            return await self.aresolve_3()
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> _ActionResolver:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        cleanup_error: BaseException | None = None
        while self._cleanup_callbacks:
            cleanup_kind, cleanup = self._cleanup_callbacks.pop()
            try:
                if cleanup_kind == 0:
                    cleanup(exc_type, exc_value, traceback)
                else:
                    msg = "Cannot execute async cleanup in sync context. Use 'async with'."
                    raise DIWireAsyncDependencyInSyncContextError(msg)
            except BaseException as error:
                if exc_type is None and cleanup_error is None:
                    cleanup_error = error
        if exc_type is None and cleanup_error is not None:
            raise cleanup_error
        return None

    async def __aenter__(self) -> _ActionResolver:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        cleanup_error: BaseException | None = None
        while self._cleanup_callbacks:
            cleanup_kind, cleanup = self._cleanup_callbacks.pop()
            try:
                if cleanup_kind == 0:
                    cleanup(exc_type, exc_value, traceback)
                else:
                    await cleanup(exc_type, exc_value, traceback)
            except BaseException as error:
                if exc_type is None and cleanup_error is None:
                    cleanup_error = error
        if exc_type is None and cleanup_error is not None:
            raise cleanup_error
        return None


    def resolve_1(self) -> Any:

        """
        Provider slot 1 resolver (sync method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource
        Provider spec kind: context_manager
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._provide_async_context_resource
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: True
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _ActionResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        owner_resolver = self._request_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 1 requires opened scope level 3."
            raise DIWireScopeMismatchError(msg)
        return owner_resolver.resolve_1()

    async def aresolve_1(self) -> Any:

        """
        Provider slot 1 resolver (async method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource
        Provider spec kind: context_manager
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._provide_async_context_resource
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: True
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _ActionResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        owner_resolver = self._request_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 1 requires opened scope level 3."
            raise DIWireScopeMismatchError(msg)
        return await owner_resolver.aresolve_1()

    def resolve_2(self) -> Any:

        """
        Provider slot 2 resolver (sync method).

        Returns: tuple
        Provider spec kind: instance
        Provider target: instance of tuple
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _ActionResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        return self._root_resolver.resolve_2()

    async def aresolve_2(self) -> Any:

        """
        Provider slot 2 resolver (async method).

        Returns: tuple
        Provider spec kind: instance
        Provider target: instance of tuple
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _ActionResolver
        Dependency wiring: none
        Behavior: Async variant delegates to sync resolution because this provider graph does not require awaitable operations.
        """

        return self.resolve_2()

    def resolve_3(self) -> Any:

        """
        Provider slot 3 resolver (sync method).

        Returns: dict
        Provider spec kind: instance
        Provider target: instance of dict
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _ActionResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        return self._root_resolver.resolve_3()

    async def aresolve_3(self) -> Any:

        """
        Provider slot 3 resolver (async method).

        Returns: dict
        Provider spec kind: instance
        Provider target: instance of dict
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _ActionResolver
        Dependency wiring: none
        Behavior: Async variant delegates to sync resolution because this provider graph does not require awaitable operations.
        """

        return self.resolve_3()

    def resolve_4(self) -> Any:

        """
        Provider slot 4 resolver (sync method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncCleanupSignatureService
        Provider spec kind: factory
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._build_snapshot_async_cleanup_signature_service
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _ActionResolver
        Dependency wiring: dependency (positional_only) -> slot 1 [tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource]; values (var_positional) -> slot 2 [tuple]; options (var_keyword) -> slot 3 [dict]
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        owner_resolver = self._request_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 4 requires opened scope level 3."
            raise DIWireScopeMismatchError(msg)
        return owner_resolver.resolve_4()

    async def aresolve_4(self) -> Any:

        """
        Provider slot 4 resolver (async method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncCleanupSignatureService
        Provider spec kind: factory
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._build_snapshot_async_cleanup_signature_service
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _ActionResolver
        Dependency wiring: dependency (positional_only) -> slot 1 [tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource]; values (var_positional) -> slot 2 [tuple]; options (var_keyword) -> slot 3 [dict]
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        owner_resolver = self._request_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 4 requires opened scope level 3."
            raise DIWireScopeMismatchError(msg)
        return await owner_resolver.aresolve_4()


class _StepResolver:

    """
    Generated resolver for scope 'step' (level 5).

    This class is generated and optimized for direct slot-based dependency resolution.
    All visible provider slots: 1, 2, 3, 4.
    Providers declared in this exact scope: none.
    """



    __slots__ = (
        "_scope_level",
        "_root_resolver",
        "_cleanup_enabled",
        "_cleanup_callbacks",
        "_session_resolver",
        "_request_resolver",
        "_action_resolver",
        "_step_resolver",
    )


    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
        session_resolver: Any = _MISSING_RESOLVER,
        request_resolver: Any = _MISSING_RESOLVER,
        action_resolver: Any = _MISSING_RESOLVER,
    ) -> None:

        """
        Initialize resolver state for the current scope.

        The constructor wires scope ancestry references, cache slots, and optional cleanup state.
        Root scope class: RootResolver.
        Stateless scope reuse enabled: False.
        """

        self._scope_level = 5
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._cleanup_callbacks: list[tuple[int, Any]] = []
        self._session_resolver = session_resolver
        self._request_resolver = request_resolver
        self._action_resolver = action_resolver
        self._step_resolver = self

    def enter_scope(self, scope: Any | None = None) -> NoReturn:

        """
        Open a deeper scope resolver from this resolver.

        Current scope: step:5.
        Allowed explicit transitions: none.
        Passing None follows the default transition for the scope graph.
        """

        msg = f"Cannot enter deeper scope from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated synchronous provider resolver method.

        Known provider slots: 1, 2, 3, 4.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks to avoid reflective dispatch.
        if dependency is _dep_1_type:
            return self.resolve_1()
        if dependency is _dep_4_type:
            return self.resolve_4()
        if dependency is _dep_2_type:
            return self.resolve_2()
        if dependency is _dep_3_type:
            return self.resolve_3()
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:

        """
        Route a dependency token to a generated asynchronous provider resolver method.

        Known provider slots: 1, 2, 3, 4.
        Dispatch uses identity checks against module-level `_dep_<slot>_type` globals.
        """

        # Fast path identity checks for asynchronous resolution.
        if dependency is _dep_1_type:
            return await self.aresolve_1()
        if dependency is _dep_4_type:
            return await self.aresolve_4()
        if dependency is _dep_2_type:
            return await self.aresolve_2()
        if dependency is _dep_3_type:
            return await self.aresolve_3()
        # Any dependency not pre-bound in build_root_resolver is unknown here.
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> _StepResolver:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        cleanup_error: BaseException | None = None
        while self._cleanup_callbacks:
            cleanup_kind, cleanup = self._cleanup_callbacks.pop()
            try:
                if cleanup_kind == 0:
                    cleanup(exc_type, exc_value, traceback)
                else:
                    msg = "Cannot execute async cleanup in sync context. Use 'async with'."
                    raise DIWireAsyncDependencyInSyncContextError(msg)
            except BaseException as error:
                if exc_type is None and cleanup_error is None:
                    cleanup_error = error
        if exc_type is None and cleanup_error is not None:
            raise cleanup_error
        return None

    async def __aenter__(self) -> _StepResolver:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        cleanup_error: BaseException | None = None
        while self._cleanup_callbacks:
            cleanup_kind, cleanup = self._cleanup_callbacks.pop()
            try:
                if cleanup_kind == 0:
                    cleanup(exc_type, exc_value, traceback)
                else:
                    await cleanup(exc_type, exc_value, traceback)
            except BaseException as error:
                if exc_type is None and cleanup_error is None:
                    cleanup_error = error
        if exc_type is None and cleanup_error is not None:
            raise cleanup_error
        return None


    def resolve_1(self) -> Any:

        """
        Provider slot 1 resolver (sync method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource
        Provider spec kind: context_manager
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._provide_async_context_resource
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: True
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _StepResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        owner_resolver = self._request_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 1 requires opened scope level 3."
            raise DIWireScopeMismatchError(msg)
        return owner_resolver.resolve_1()

    async def aresolve_1(self) -> Any:

        """
        Provider slot 1 resolver (async method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource
        Provider spec kind: context_manager
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._provide_async_context_resource
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: True
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _StepResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        owner_resolver = self._request_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 1 requires opened scope level 3."
            raise DIWireScopeMismatchError(msg)
        return await owner_resolver.aresolve_1()

    def resolve_2(self) -> Any:

        """
        Provider slot 2 resolver (sync method).

        Returns: tuple
        Provider spec kind: instance
        Provider target: instance of tuple
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _StepResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        return self._root_resolver.resolve_2()

    async def aresolve_2(self) -> Any:

        """
        Provider slot 2 resolver (async method).

        Returns: tuple
        Provider spec kind: instance
        Provider target: instance of tuple
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _StepResolver
        Dependency wiring: none
        Behavior: Async variant delegates to sync resolution because this provider graph does not require awaitable operations.
        """

        return self.resolve_2()

    def resolve_3(self) -> Any:

        """
        Provider slot 3 resolver (sync method).

        Returns: dict
        Provider spec kind: instance
        Provider target: instance of dict
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _StepResolver
        Dependency wiring: none
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        return self._root_resolver.resolve_3()

    async def aresolve_3(self) -> Any:

        """
        Provider slot 3 resolver (async method).

        Returns: dict
        Provider spec kind: instance
        Provider target: instance of dict
        Declared scope: app (level 1)
        Declared lifetime: transient
        Cache policy: cached
        Cache owner scope: 1
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: False
        Cleanup callbacks required: False
        Resolver class handling this call: _StepResolver
        Dependency wiring: none
        Behavior: Async variant delegates to sync resolution because this provider graph does not require awaitable operations.
        """

        return self.resolve_3()

    def resolve_4(self) -> Any:

        """
        Provider slot 4 resolver (sync method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncCleanupSignatureService
        Provider spec kind: factory
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._build_snapshot_async_cleanup_signature_service
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _StepResolver
        Dependency wiring: dependency (positional_only) -> slot 1 [tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource]; values (var_positional) -> slot 2 [tuple]; options (var_keyword) -> slot 3 [dict]
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        owner_resolver = self._request_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 4 requires opened scope level 3."
            raise DIWireScopeMismatchError(msg)
        return owner_resolver.resolve_4()

    async def aresolve_4(self) -> Any:

        """
        Provider slot 4 resolver (async method).

        Returns: tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncCleanupSignatureService
        Provider spec kind: factory
        Provider target: tests.unit.internal.test_resolver_codegen_expected_output._build_snapshot_async_cleanup_signature_service
        Declared scope: request (level 3)
        Declared lifetime: scoped
        Cache policy: cached
        Cache owner scope: 3
        Concurrency-safe provider: True
        Provider declared async: False
        Graph requires async: True
        Cleanup callbacks required: True
        Resolver class handling this call: _StepResolver
        Dependency wiring: dependency (positional_only) -> slot 1 [tests.unit.internal.test_resolver_codegen_expected_output._SnapshotAsyncContextResource]; values (var_positional) -> slot 2 [tuple]; options (var_keyword) -> slot 3 [dict]
        Behavior: This resolver delegates to the cache owner resolver so scoped caching remains consistent across nested resolvers.
        """

        owner_resolver = self._request_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 4 requires opened scope level 3."
            raise DIWireScopeMismatchError(msg)
        return await owner_resolver.aresolve_4()

def build_root_resolver(
    registrations: ProvidersRegistrations,
    *,
    cleanup_enabled: bool = True,
) -> RootResolver:

    """
    Build and return the generated root resolver instance.

    This function rebinds module-level provider globals for the supplied registrations.
    Global rebinding makes `resolve_<slot>` methods run without registration lookups.
    Provider slots configured during bootstrap: 1, 2, 3, 4.
    Root resolver class: RootResolver.

    Examples:
    >>> root = build_root_resolver(registrations)
    >>> root.resolve(SomeService)
    >>> await root.aresolve(SomeAsyncService)
    >>> scoped = root.enter_scope()
    """

    # Bind module-level globals to this container registration snapshot.
    # This keeps hot paths in resolver methods free from dictionary lookups.
    global _dep_1_type, _provider_1
    global _dep_2_type, _provider_2
    global _dep_3_type, _provider_3
    global _dep_4_type, _provider_4

    # --- Provider slot 1 bootstrap metadata ---
    # Read provider spec by stable slot id from registrations.
    registration_1 = registrations.get_by_slot(1)
    # Capture dependency identity token used by `resolve`/`aresolve` dispatch.
    _dep_1_type = registration_1.provides
    # Capture provider object (instance/type/factory/generator/context manager).
    _provider_1 = registration_1.context_manager

    # --- Provider slot 2 bootstrap metadata ---
    # Read provider spec by stable slot id from registrations.
    registration_2 = registrations.get_by_slot(2)
    # Capture dependency identity token used by `resolve`/`aresolve` dispatch.
    _dep_2_type = registration_2.provides
    # Capture provider object (instance/type/factory/generator/context manager).
    _provider_2 = registration_2.instance

    # --- Provider slot 3 bootstrap metadata ---
    # Read provider spec by stable slot id from registrations.
    registration_3 = registrations.get_by_slot(3)
    # Capture dependency identity token used by `resolve`/`aresolve` dispatch.
    _dep_3_type = registration_3.provides
    # Capture provider object (instance/type/factory/generator/context manager).
    _provider_3 = registration_3.instance

    # --- Provider slot 4 bootstrap metadata ---
    # Read provider spec by stable slot id from registrations.
    registration_4 = registrations.get_by_slot(4)
    # Capture dependency identity token used by `resolve`/`aresolve` dispatch.
    _dep_4_type = registration_4.provides
    # Capture provider object (instance/type/factory/generator/context manager).
    _provider_4 = registration_4.factory

    # Construct a fresh root resolver configured with optional cleanup callbacks.
    return RootResolver(cleanup_enabled)