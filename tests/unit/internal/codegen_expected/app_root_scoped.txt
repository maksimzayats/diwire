from __future__ import annotations

import threading


from types import TracebackType
from typing import Any

from diwire.exceptions import (
    DIWireAsyncDependencyInSyncContextError,
    DIWireDependencyNotRegisteredError,
    DIWireScopeMismatchError,
)
from diwire.providers import ProvidersRegistrations
from diwire.resolvers.protocol import ResolverProtocol

_MISSING_RESOLVER: Any = object()
_MISSING_CACHE: Any = object()
_MISSING_PROVIDER: Any = object()

_dep_1_type: Any = _MISSING_PROVIDER
_provider_1: Any = _MISSING_PROVIDER
_dep_2_type: Any = _MISSING_PROVIDER
_provider_2: Any = _MISSING_PROVIDER


_dep_1_thread_lock = threading.Lock()
_dep_2_thread_lock = threading.Lock()

class RootResolver:
    def __init__(
        self,
        cleanup_enabled: bool = True,
    ) -> None:
        self._scope_level = 1
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = self
        self._app_resolver = self._root_resolver

    def enter_scope(self, scope: Any | None = None) -> ResolverProtocol:
        if scope is None:
            return _RequestResolver(
                self._root_resolver,
                self._cleanup_enabled,
                _MISSING_RESOLVER,
            )
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 2:
            return _SessionResolver(
                self._root_resolver,
                self._cleanup_enabled,
            )
        if target_scope_level == 3:
            return _RequestResolver(
                self._root_resolver,
                self._cleanup_enabled,
                _MISSING_RESOLVER,
            )
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:
        if dependency is _dep_1_type:
            return self.resolve_1()
        if dependency is _dep_2_type:
            return self.resolve_2()
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:
        if dependency is _dep_1_type:
            return await self.aresolve_1()
        if dependency is _dep_2_type:
            return await self.aresolve_2()
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> ResolverProtocol:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> ResolverProtocol:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


    def resolve_1(self) -> Any:
        msg = "Provider slot 1 requires opened scope level 2."
        raise DIWireScopeMismatchError(msg)

    async def aresolve_1(self) -> Any:
        return self.resolve_1()

    def resolve_2(self) -> Any:
        msg = "Provider slot 2 requires opened scope level 3."
        raise DIWireScopeMismatchError(msg)

    async def aresolve_2(self) -> Any:
        return self.resolve_2()


class _SessionResolver:
    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
    ) -> None:
        self._scope_level = 2
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._app_resolver = self._root_resolver
        self._session_resolver = self
        self._cache_1 = _MISSING_CACHE

    def enter_scope(self, scope: Any | None = None) -> ResolverProtocol:
        if scope is None:
            return _RequestResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self,
            )
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 3:
            return _RequestResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self,
            )
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:
        if dependency is _dep_1_type:
            return self.resolve_1()
        if dependency is _dep_2_type:
            return self.resolve_2()
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:
        if dependency is _dep_1_type:
            return await self.aresolve_1()
        if dependency is _dep_2_type:
            return await self.aresolve_2()
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> ResolverProtocol:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> ResolverProtocol:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


    def resolve_1(self) -> Any:
        provider_scope_resolver = self
        cached_value = self._cache_1
        if cached_value is not _MISSING_CACHE:
            return cached_value
        with _dep_1_thread_lock:
            cached_value = self._cache_1
            if cached_value is not _MISSING_CACHE:
                return cached_value
            value = _provider_1()
            self._cache_1 = value
            self.resolve_1 = lambda: value

            async def _cached() -> Any:
                return value

            self.aresolve_1 = _cached
            return value

    async def aresolve_1(self) -> Any:
        return self.resolve_1()

    def resolve_2(self) -> Any:
        msg = "Provider slot 2 requires opened scope level 3."
        raise DIWireScopeMismatchError(msg)

    async def aresolve_2(self) -> Any:
        return self.resolve_2()


class _RequestResolver:
    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
        session_resolver: Any = _MISSING_RESOLVER,
    ) -> None:
        self._scope_level = 3
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._app_resolver = self._root_resolver
        self._session_resolver = session_resolver
        self._request_resolver = self
        self._cache_2 = _MISSING_CACHE

    def enter_scope(self, scope: Any | None = None) -> ResolverProtocol:
        if scope is None:
            return _ActionResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self._session_resolver,
                self,
            )
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 4:
            return _ActionResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self._session_resolver,
                self,
            )
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:
        if dependency is _dep_1_type:
            return self.resolve_1()
        if dependency is _dep_2_type:
            return self.resolve_2()
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:
        if dependency is _dep_1_type:
            return await self.aresolve_1()
        if dependency is _dep_2_type:
            return await self.aresolve_2()
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> ResolverProtocol:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> ResolverProtocol:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


    def resolve_1(self) -> Any:
        owner_resolver = self._session_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 1 requires opened scope level 2."
            raise DIWireScopeMismatchError(msg)
        return owner_resolver.resolve_1()

    async def aresolve_1(self) -> Any:
        return self.resolve_1()

    def resolve_2(self) -> Any:
        provider_scope_resolver = self
        cached_value = self._cache_2
        if cached_value is not _MISSING_CACHE:
            return cached_value
        with _dep_2_thread_lock:
            cached_value = self._cache_2
            if cached_value is not _MISSING_CACHE:
                return cached_value
            value = _provider_2(
                session=self.resolve_1(),
            )
            self._cache_2 = value
            self.resolve_2 = lambda: value

            async def _cached() -> Any:
                return value

            self.aresolve_2 = _cached
            return value

    async def aresolve_2(self) -> Any:
        return self.resolve_2()


class _ActionResolver:
    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
        session_resolver: Any = _MISSING_RESOLVER,
        request_resolver: Any = _MISSING_RESOLVER,
    ) -> None:
        self._scope_level = 4
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._app_resolver = self._root_resolver
        self._session_resolver = session_resolver
        self._request_resolver = request_resolver
        self._action_resolver = self

    def enter_scope(self, scope: Any | None = None) -> ResolverProtocol:
        if scope is None:
            return _StepResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self._session_resolver,
                self._request_resolver,
                self,
            )
        target_scope_level = scope.level
        if target_scope_level == self._scope_level:
            return self
        if target_scope_level <= self._scope_level:
            msg = f"Cannot enter scope level {target_scope_level} from level {self._scope_level}."
            raise DIWireScopeMismatchError(msg)
        if target_scope_level == 5:
            return _StepResolver(
                self._root_resolver,
                self._cleanup_enabled,
                self._session_resolver,
                self._request_resolver,
                self,
            )
        msg = f"Scope level {target_scope_level} is not a valid next transition from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:
        if dependency is _dep_1_type:
            return self.resolve_1()
        if dependency is _dep_2_type:
            return self.resolve_2()
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:
        if dependency is _dep_1_type:
            return await self.aresolve_1()
        if dependency is _dep_2_type:
            return await self.aresolve_2()
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> ResolverProtocol:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> ResolverProtocol:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


    def resolve_1(self) -> Any:
        owner_resolver = self._session_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 1 requires opened scope level 2."
            raise DIWireScopeMismatchError(msg)
        return owner_resolver.resolve_1()

    async def aresolve_1(self) -> Any:
        return self.resolve_1()

    def resolve_2(self) -> Any:
        owner_resolver = self._request_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 2 requires opened scope level 3."
            raise DIWireScopeMismatchError(msg)
        return owner_resolver.resolve_2()

    async def aresolve_2(self) -> Any:
        return self.resolve_2()


class _StepResolver:
    def __init__(
        self,
        root_resolver: RootResolver,
        cleanup_enabled: bool = True,
        session_resolver: Any = _MISSING_RESOLVER,
        request_resolver: Any = _MISSING_RESOLVER,
        action_resolver: Any = _MISSING_RESOLVER,
    ) -> None:
        self._scope_level = 5
        self._cleanup_enabled = cleanup_enabled
        self._root_resolver = root_resolver
        self._app_resolver = self._root_resolver
        self._session_resolver = session_resolver
        self._request_resolver = request_resolver
        self._action_resolver = action_resolver
        self._step_resolver = self

    def enter_scope(self, scope: Any | None = None) -> ResolverProtocol:
        msg = f"Cannot enter deeper scope from level {self._scope_level}."
        raise DIWireScopeMismatchError(msg)

    def resolve(self, dependency: Any) -> Any:
        if dependency is _dep_1_type:
            return self.resolve_1()
        if dependency is _dep_2_type:
            return self.resolve_2()
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    async def aresolve(self, dependency: Any) -> Any:
        if dependency is _dep_1_type:
            return await self.aresolve_1()
        if dependency is _dep_2_type:
            return await self.aresolve_2()
        msg = f"Dependency {dependency!r} is not registered."
        raise DIWireDependencyNotRegisteredError(msg)

    def __enter__(self) -> ResolverProtocol:
        return self

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None

    async def __aenter__(self) -> ResolverProtocol:
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        return None


    def resolve_1(self) -> Any:
        owner_resolver = self._session_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 1 requires opened scope level 2."
            raise DIWireScopeMismatchError(msg)
        return owner_resolver.resolve_1()

    async def aresolve_1(self) -> Any:
        return self.resolve_1()

    def resolve_2(self) -> Any:
        owner_resolver = self._request_resolver
        if owner_resolver is _MISSING_RESOLVER:
            msg = "Provider slot 2 requires opened scope level 3."
            raise DIWireScopeMismatchError(msg)
        return owner_resolver.resolve_2()

    async def aresolve_2(self) -> Any:
        return self.resolve_2()

def build_root_resolver(
    registrations: ProvidersRegistrations,
    *,
    cleanup_enabled: bool = True,
) -> ResolverProtocol:
    global _dep_1_type, _provider_1
    global _dep_2_type, _provider_2

    registration_1 = registrations.get_by_slot(1)
    _dep_1_type = registration_1.provides
    _provider_1 = registration_1.concrete_type

    registration_2 = registrations.get_by_slot(2)
    _dep_2_type = registration_2.provides
    _provider_2 = registration_2.concrete_type

    return RootResolver(cleanup_enabled)