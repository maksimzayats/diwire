from __future__ import annotations

import inspect
from collections.abc import AsyncGenerator, Generator
from contextlib import asynccontextmanager, contextmanager

import pytest

from diwire.container import Container
from diwire.exceptions import DIWireInvalidProviderSpecError
from diwire.providers import Lifetime, ProviderDependency, ProviderSpec, ProvidersRegistrations
from diwire.resolvers.templates.planner import LockMode, ResolverGenerationPlanner
from diwire.resolvers.templates.renderer import ResolversTemplateRenderer
from diwire.scope import Scope


class _Config:
    pass


class _Service:
    def __init__(self, config: _Config) -> None:
        self.config = config


class _AsyncService:
    def __init__(self, value: int) -> None:
        self.value = value


class _GeneratorService:
    pass


class _AsyncGeneratorService:
    pass


class _ContextManagerService:
    pass


class _AsyncContextManagerService:
    pass


class _DependencyShapeService:
    def __init__(
        self,
        positional: int,
        values: tuple[int, ...],
        options: dict[str, int],
    ) -> None:
        self.positional = positional
        self.values = values
        self.options = options


class _CycleA:
    pass


class _CycleB:
    pass


class _RequestRootOnlyService:
    pass


class _RequestRootSessionService:
    pass


async def _provide_int() -> int:
    return 42


async def _provide_async_service(value: int) -> _AsyncService:
    return _AsyncService(value)


def _provide_generator_service() -> Generator[_GeneratorService, None, None]:
    yield _GeneratorService()


async def _provide_async_generator_service() -> AsyncGenerator[_AsyncGeneratorService, None]:
    yield _AsyncGeneratorService()


@contextmanager
def _provide_context_manager_service() -> Generator[_ContextManagerService, None, None]:
    yield _ContextManagerService()


@asynccontextmanager
async def _provide_async_context_manager_service() -> AsyncGenerator[
    _AsyncContextManagerService,
    None,
]:
    yield _AsyncContextManagerService()


def _provide_dependency_shape_service(
    positional: int,
    /,
    *values: int,
    **options: int,
) -> _DependencyShapeService:
    return _DependencyShapeService(positional=positional, values=tuple(values), options=options)


def _provide_cycle_a(dep_b: _CycleB) -> _CycleA:
    return _CycleA()


def _provide_cycle_b(dep_a: _CycleA) -> _CycleB:
    return _CycleB()


def test_renderer_output_is_deterministic_and_composable() -> None:
    container = Container()
    container.register_instance(_Config, instance=_Config())
    container.register_concrete(_Service, concrete_type=_Service, lifetime=Lifetime.TRANSIENT)

    renderer = ResolversTemplateRenderer()
    code_first = renderer.get_providers_code(
        root_scope=Scope.APP,
        registrations=container._providers_registrations,
    )
    code_second = renderer.get_providers_code(
        root_scope=Scope.APP,
        registrations=container._providers_registrations,
    )

    assert code_first == code_second
    assert "class RootResolver:" in code_first
    assert "def build_root_resolver(" in code_first
    assert "ResolverProtocol" not in code_first
    assert ") -> RootResolver:" in code_first
    assert "def __enter__(self) -> RootResolver:" in code_first
    assert "async def __aenter__(self) -> RootResolver:" in code_first
    assert (
        "def enter_scope(self, scope: Any | None = None) -> "
        "RootResolver | _SessionResolver | _RequestResolver:"
    ) in code_first
    assert "def enter_scope(self, scope: Any | None = None) -> NoReturn:" in code_first
    assert "def resolve(self, dependency: Any) -> Any:" in code_first
    assert "async def aresolve(self, dependency: Any) -> Any:" in code_first
    assert code_first.startswith('"""')
    assert (
        "Generated by: diwire.resolvers.templates.renderer."
        "ResolversTemplateRenderer.get_providers_code"
    ) in code_first
    assert "diwire version used for generation:" in code_first
    assert "Generation configuration:" in code_first
    assert "Examples:" in code_first
    assert "Provider slot " in code_first
    assert "Returns: " in code_first
    assert "Provider spec kind: " in code_first
    assert "Dependency wiring:" in code_first
    assert "# Bind module-level globals to this container registration snapshot." in code_first
    assert (
        "# Capture dependency identity token used by `resolve`/`aresolve` dispatch." in code_first
    )


def test_renderer_output_avoids_reflective_hot_path_tokens() -> None:
    container = Container()
    container.register_instance(_Config, instance=_Config())
    container.register_concrete(_Service, concrete_type=_Service, lifetime=Lifetime.SINGLETON)

    code = ResolversTemplateRenderer().get_providers_code(
        root_scope=Scope.APP,
        registrations=container._providers_registrations,
    )

    assert "getattr(" not in code
    assert "__dict__" not in code
    assert "cast(" not in code


def test_planner_selects_async_lock_mode_when_async_specs_exist() -> None:
    container = Container()
    container.register_factory(int, factory=_provide_int, lifetime=Lifetime.SINGLETON)
    container.register_factory(
        _AsyncService,
        factory=_provide_async_service,
        lifetime=Lifetime.SINGLETON,
    )

    plan = ResolverGenerationPlanner(
        root_scope=Scope.APP,
        registrations=container._providers_registrations,
    ).build()

    assert plan.lock_mode is LockMode.ASYNC


def test_renderer_includes_generator_context_helpers_for_generator_graphs() -> None:
    container = Container()
    container.register_generator(
        _GeneratorService,
        generator=_provide_generator_service,
        lifetime=Lifetime.SCOPED,
        scope=Scope.REQUEST,
    )
    container.register_generator(
        _AsyncGeneratorService,
        generator=_provide_async_generator_service,
        lifetime=Lifetime.SCOPED,
        scope=Scope.REQUEST,
    )

    code = ResolversTemplateRenderer().get_providers_code(
        root_scope=Scope.APP,
        registrations=container._providers_registrations,
    )

    assert "from contextlib import asynccontextmanager, contextmanager" in code
    assert "contextmanager(_provider_" in code
    assert "value = _provider_cm.__enter__()" in code
    assert "value = next(_provider_gen)" in code
    assert "asynccontextmanager(_provider_" in code
    assert "value = await _provider_cm.__aenter__()" in code
    assert "value = await anext(_provider_gen)" in code


def test_renderer_does_not_add_generator_helpers_for_context_manager_only_graphs() -> None:
    container = Container()
    container.register_context_manager(
        _ContextManagerService,
        context_manager=_provide_context_manager_service,
        lifetime=Lifetime.SCOPED,
        scope=Scope.REQUEST,
    )

    code = ResolversTemplateRenderer().get_providers_code(
        root_scope=Scope.APP,
        registrations=container._providers_registrations,
    )

    assert "from contextlib import asynccontextmanager, contextmanager" not in code
    assert "value = _provider_cm.__enter__()" in code


def test_renderer_emits_async_context_manager_branch_for_async_context_manager_specs() -> None:
    container = Container()
    container.register_context_manager(
        _AsyncContextManagerService,
        context_manager=_provide_async_context_manager_service,
        lifetime=Lifetime.SCOPED,
        scope=Scope.REQUEST,
    )

    code = ResolversTemplateRenderer().get_providers_code(
        root_scope=Scope.APP,
        registrations=container._providers_registrations,
    )

    assert "value = await _provider_cm.__aenter__()" in code
    assert "provider_scope_resolver._cleanup_callbacks.append((1, _provider_cm.__aexit__))" in code
    assert "asynccontextmanager(_provider_" not in code


def test_renderer_dependency_wiring_supports_positional_varargs_and_varkw() -> None:
    signature = inspect.signature(_provide_dependency_shape_service)
    positional_type = int
    values_type = tuple[int, ...]
    options_type = dict[str, int]

    container = Container()
    container.register_instance(provides=positional_type, instance=1)
    container.register_instance(provides=values_type, instance=(2, 3))
    container.register_instance(provides=options_type, instance={"first": 1, "second": 2})
    container.register_factory(
        _DependencyShapeService,
        factory=_provide_dependency_shape_service,
        dependencies=[
            ProviderDependency(
                provides=positional_type,
                parameter=signature.parameters["positional"],
            ),
            ProviderDependency(
                provides=values_type,
                parameter=signature.parameters["values"],
            ),
            ProviderDependency(
                provides=options_type,
                parameter=signature.parameters["options"],
            ),
        ],
    )

    code = ResolversTemplateRenderer().get_providers_code(
        root_scope=Scope.APP,
        registrations=container._providers_registrations,
    )

    assert "positional=self.resolve_" not in code
    assert "*self.resolve_" in code
    assert "**self.resolve_" in code


def test_renderer_raises_for_circular_dependency_graph() -> None:
    container = Container()
    container.register_factory(_CycleA, factory=_provide_cycle_a)
    container.register_factory(_CycleB, factory=_provide_cycle_b)

    with pytest.raises(DIWireInvalidProviderSpecError, match="Circular dependency detected"):
        ResolversTemplateRenderer().get_providers_code(
            root_scope=Scope.APP,
            registrations=container._providers_registrations,
        )


def test_renderer_documents_instance_lifetime_as_none() -> None:
    registrations = ProvidersRegistrations()
    registrations.add(
        ProviderSpec(
            provides=_Config,
            instance=_Config(),
            lifetime=None,
            scope=Scope.APP,
            is_async=False,
            is_any_dependency_async=False,
            needs_cleanup=False,
            concurrency_safe=True,
        ),
    )

    code = ResolversTemplateRenderer().get_providers_code(
        root_scope=Scope.APP,
        registrations=registrations,
    )

    assert "Provider spec kind: instance" in code
    assert "Declared lifetime: none" in code


def test_renderer_filters_providers_and_scopes_when_root_scope_is_request() -> None:
    container = Container()
    container.register_concrete(
        _Config,
        concrete_type=_Config,
        scope=Scope.APP,
        lifetime=Lifetime.SINGLETON,
    )
    container.register_concrete(
        _RequestRootSessionService,
        concrete_type=_RequestRootSessionService,
        scope=Scope.SESSION,
        lifetime=Lifetime.SCOPED,
    )
    container.register_concrete(
        _RequestRootOnlyService,
        concrete_type=_RequestRootOnlyService,
        scope=Scope.REQUEST,
        lifetime=Lifetime.SCOPED,
    )

    code = ResolversTemplateRenderer().get_providers_code(
        root_scope=Scope.REQUEST,
        registrations=container._providers_registrations,
    )

    assert "root scope level: 3" in code
    assert "managed scopes: request:3, action:4, step:5" in code
    assert "class _SessionResolver:" not in code
    assert "session:2" not in code
    assert "Provider target: " in code
    assert "_RequestRootOnlyService" in code
